name: Release Build for BA services

permissions:
  contents: read

on:
  workflow_dispatch:
    inputs:
      build_ref:
        description: 'Branch or tag to build from'
        required: true
        default: 'main'
        type: string
      build_flavor:
        description: 'Build flavor'
        required: true
        default: 'non_prod'
        type: choice
        options:
        - non_prod
        - prod
      run_tests:
        description: 'Run tests'
        required: true
        default: false
        type: boolean
      run_precommit_checks:
        description: 'Run precommit checks'
        required: true
        default: false
        type: boolean
      services:
        description: 'Services to build (comma-separated)'
        required: true
        default: 'bidding_service,buyer_frontend_service'
        type: string
      release_tag:
        description: 'Release version for Docker images (e.g., 4.8.0.1)'
        required: true
        default: '4.8.0.4'
        type: string
      push_to_acr:
        description: 'Push images to Azure Container Registry'
        required: true
        default: true
        type: boolean
      generate_sboms:
        description: 'Generate SBOMs (requires push to ACR)'
        required: true
        default: false
        type: boolean

env:
  BUILD_TYPE: Release
  REGISTRY: ${{ vars.REGISTRY }}
  REPO_PATH: ${{ vars.REPO_PATH }}
  
jobs:
  build:
    runs-on: self-hosted
    timeout-minutes: 1440 # 24 hours
    steps:
    - name: Initial Cleanup (Pre-Build)
      run: |
        echo "üßπ Performing initial cleanup to ensure clean build environment..."
        # Clean up any existing Docker artifacts
        echo "Cleaning existing Docker containers and images..."
        docker container prune -f || true
        docker image prune -a -f || true
        docker system prune -f || true
        
        # Clean up workspace from previous runs
        echo "Cleaning workspace from previous runs..."
        sudo rm -rf ${GITHUB_WORKSPACE}/* || true
        sudo rm -rf ${GITHUB_WORKSPACE}/.* 2>/dev/null || true
        
        # Clean up dist directories from previous builds
        echo "Cleaning up distribution directories..."
        sudo rm -rf ./dist/ || true
        sudo rm -rf ../dist/ || true

    - name: Display Manual Trigger Parameters
      run: |
        echo "üöÄ Manual Build Triggered on Self-Hosted Runner"
        echo "Build Ref: ${{ github.event.inputs.build_ref }}"
        echo "Build Flavor: ${{ github.event.inputs.build_flavor }}"
        echo "Run tests?: ${{ github.event.inputs.run_tests }}"
        echo "Run precommit checks?: ${{ github.event.inputs.run_precommit_checks }}"
        echo "Services: ${{ github.event.inputs.services }}"
        echo "Release Version: ${{ github.event.inputs.release_tag }}"
        echo "Push to ACR: ${{ github.event.inputs.push_to_acr }}"
        echo "Generate SBOMs: ${{ github.event.inputs.generate_sboms }}"

    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        repository: ispirt/ad-selection-api.bidding-and-auction-servers
        ref: ${{ github.event.inputs.build_ref }}
        fetch-depth: 0
        
    - name: Setup Build Environment
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake git

    - name: Setup Dependencies  
      run: |
        # Remove any conflicting Docker packages
        sudo apt-get remove -y docker docker-engine docker.io containerd runc || true
        sudo apt-get autoremove -y
        
        # Install build dependencies
        sudo apt-get install -y \
          apt-transport-https \
          ca-certificates \
          curl \
          gnupg \
          lsb-release \
          libssl-dev \
          libcurl4-openssl-dev \
          libprotobuf-dev \
          protobuf-compiler \
          pkg-config

    - name: Install Docker
      run: |
        # Free up memory first
        sudo apt-get clean
        sudo apt-get autoclean
        sudo rm -rf /var/lib/apt/lists/*
        
        # Download and run Docker installation script
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        
        # Clean up installation script
        rm get-docker.sh
        
        # Add user to docker group
        sudo usermod -aG docker $USER        
        
        # Verify installation
        docker --version

    - name: Setup Docker
      run: |
        sudo systemctl start docker
        sudo systemctl enable docker
        sudo usermod -aG docker $USER

    - name: Make Build Script Executable
      run: |
        chmod +x ./production/packaging/build_and_test_all_in_docker
        
    - name: Parse Service Paths
      id: parse_services
      run: |
        # Convert comma-separated services to --service-path arguments
        services="${{ github.event.inputs.services }}"
        service_args=""
        IFS=',' read -ra SERVICE_ARRAY <<< "$services"
        for service in "${SERVICE_ARRAY[@]}"; do
          service_args="$service_args --service-path ${service// /}"
        done
        echo "service_args=$service_args" >> $GITHUB_OUTPUT
        echo "Parsed service arguments: $service_args"
        
    - name: Run Custom Build Command
      run: |
        TEST_FLAG="--no-tests"
        PRECOMMIT_FLAG="--no-precommit"

        if [ "${{ github.event.inputs.run_tests }}" = "true" ]; then
          TEST_FLAG=""
        fi

        if [ "${{ github.event.inputs.run_precommit_checks }}" = "true" ]; then
          PRECOMMIT_FLAG=""
        fi

        ./production/packaging/build_and_test_all_in_docker \
          ${{ steps.parse_services.outputs.service_args }} \
          $TEST_FLAG \
          $PRECOMMIT_FLAG \
          --build-flavor ${{ github.event.inputs.build_flavor }} \
          --platform azure \
          --instance local
          
    - name: List Generated Tar Files
      run: |
        echo "Contents of dist/azure directory:"
        ls -la dist/azure/ || echo "dist/azure directory not found"
        find dist/azure/ -name "*.tar" -type f | head -10

    - name: Cleanup build artifacts (Build Job)
      if: always()  
      run: |
        echo "üßπ Cleaning up build artifacts from build job..."
        
        # Clean up Docker artifacts
        echo "Cleaning Docker containers and images..."
        docker container prune -f || true
        docker image prune -f || true
        
        # Clean up any problematic nested directories created during build
        echo "Cleaning up nested bidding-and-auction-servers directories..."
        sudo rm -rf ./bidding-and-auction-servers/ || true
        sudo rm -rf ../bidding-and-auction-servers/ || true
        
        # Clean up temporary files and caches
        echo "Cleaning up temporary files..."
        sudo rm -rf /tmp/docker-* || true
        sudo rm -rf /tmp/buildkit-* || true
        
        # Fix permissions on workspace files
        echo "Fixing workspace permissions..."
        sudo chown -R $(whoami):$(whoami) ${GITHUB_WORKSPACE} || true
        
        # Show disk space after cleanup
        echo "üìä Disk space after cleanup:"
        df -h
        
        echo "‚úÖ Build job cleanup completed"

  docker-push-to-acr:
    needs: build
    runs-on: self-hosted
    if: ${{ github.event.inputs.push_to_acr == 'true' }}    

    steps:
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
        password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}

    - name: Generate Service-Specific Docker Tags
      id: generate_tags
      run: |
        BUILD_FLAVOR_INPUT="${{ github.event.inputs.build_flavor }}"
        if [ "$BUILD_FLAVOR_INPUT" = "non_prod" ]; then
          BUILD_FLAVOR="nonprod"
        else
          BUILD_FLAVOR="$BUILD_FLAVOR_INPUT"
        fi
        RELEASE_VERSION="${{ github.event.inputs.release_tag }}"

        # Generate service-specific tags
        BIDDING_SERVICE_IMAGE="bidding-service:${BUILD_FLAVOR}-${RELEASE_VERSION}"
        BUYER_FRONTEND_IMAGE="buyer-frontend-service:${BUILD_FLAVOR}-${RELEASE_VERSION}"
        
        echo "bidding_service_image=$BIDDING_SERVICE_IMAGE" >> $GITHUB_OUTPUT
        echo "buyer_frontend_image=$BUYER_FRONTEND_IMAGE" >> $GITHUB_OUTPUT
        
        echo "‚úÖ Service-specific Docker tags generated:"
        echo "  Bidding Service: $BIDDING_SERVICE_IMAGE"
        echo "  Buyer Frontend Service: $BUYER_FRONTEND_IMAGE"

    - name: Load, Squash, and Push Bidding Service Image
      if: contains(github.event.inputs.services, 'bidding_service')
      run: |
        if [ -f "./dist/azure/bidding_service_image.tar" ]; then
          echo "Loading bidding_service_image.tar..."
          LOAD_OUTPUT=$(docker load -i ./dist/azure/bidding_service_image.tar)
          LOADED_IMAGE=$(echo "$LOAD_OUTPUT" | grep "Loaded image:" | sed 's/Loaded image: //')
          echo "Loaded image: $LOADED_IMAGE"

          # Squash to single layer for Azure confidential container CCE policy compatibility
          echo "üîß Squashing image layers for CCE policy compatibility..."
          docker create --name bidding-squash-temp "$LOADED_IMAGE"
          docker export bidding-squash-temp -o bidding-squashed.tar
          docker import bidding-squashed.tar bidding-squashed-base:temp

          ENTRYPOINT_JSON=$(docker inspect "$LOADED_IMAGE" --format '{{json .Config.Entrypoint}}')
          CMD_JSON=$(docker inspect "$LOADED_IMAGE" --format '{{json .Config.Cmd}}')
          ENV_VARS=$(docker inspect "$LOADED_IMAGE" --format '{{range .Config.Env}}ENV {{.}}{{"\n"}}{{end}}')
          WORKDIR=$(docker inspect "$LOADED_IMAGE" --format '{{.Config.WorkingDir}}')
          echo "Original ENTRYPOINT: $ENTRYPOINT_JSON"
          echo "Original CMD: $CMD_JSON"

          {
            echo "FROM bidding-squashed-base:temp"
            echo "$ENV_VARS"
            echo "WORKDIR ${WORKDIR:-/}"
            if [ "$ENTRYPOINT_JSON" != "null" ] && [ -n "$ENTRYPOINT_JSON" ]; then
              echo "ENTRYPOINT $ENTRYPOINT_JSON"
            fi
            if [ "$CMD_JSON" != "null" ] && [ -n "$CMD_JSON" ]; then
              echo "CMD $CMD_JSON"
            fi
          } > Dockerfile.bidding-squashed

          echo "Generated Dockerfile:" && cat Dockerfile.bidding-squashed
          docker build -f Dockerfile.bidding-squashed -t bidding-squashed-final:temp .

          LAYER_COUNT=$(docker inspect bidding-squashed-final:temp | jq '.[0].RootFS.Layers | length')
          echo "Squashed image has $LAYER_COUNT layer(s)"

          docker rm bidding-squash-temp
          docker rmi bidding-squashed-base:temp || true
          rm -f bidding-squashed.tar Dockerfile.bidding-squashed

          SERVICE_REPO_PATH="${{ env.REPO_PATH }}"
          docker tag bidding-squashed-final:temp ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.bidding_service_image}}
          echo "Pushing bidding service to ACR..."
          docker push ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.bidding_service_image}}

          echo "‚úÖ Successfully pushed bidding service image (squashed):"
          echo "  - ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.bidding_service_image }}"

          docker rmi bidding-squashed-final:temp || true
          docker rmi "$LOADED_IMAGE" || true
        else
          echo "‚ùå bidding_service_image.tar not found"
          exit 1
        fi

    - name: Load, Squash, and Push Buyer Frontend Service Image
      if: contains(github.event.inputs.services, 'buyer_frontend_service')
      run: |
        if [ -f "./dist/azure/buyer_frontend_service_image.tar" ]; then
          echo "Loading buyer_frontend_service_image.tar..."
          LOAD_OUTPUT=$(docker load -i ./dist/azure/buyer_frontend_service_image.tar)
          LOADED_IMAGE=$(echo "$LOAD_OUTPUT" | grep "Loaded image:" | sed 's/Loaded image: //')
          echo "Loaded image: $LOADED_IMAGE"

          # Squash to single layer for Azure confidential container CCE policy compatibility
          echo "üîß Squashing image layers for CCE policy compatibility..."
          docker create --name bfe-squash-temp "$LOADED_IMAGE"
          docker export bfe-squash-temp -o bfe-squashed.tar
          docker import bfe-squashed.tar bfe-squashed-base:temp

          ENTRYPOINT_JSON=$(docker inspect "$LOADED_IMAGE" --format '{{json .Config.Entrypoint}}')
          CMD_JSON=$(docker inspect "$LOADED_IMAGE" --format '{{json .Config.Cmd}}')
          ENV_VARS=$(docker inspect "$LOADED_IMAGE" --format '{{range .Config.Env}}ENV {{.}}{{"\n"}}{{end}}')
          WORKDIR=$(docker inspect "$LOADED_IMAGE" --format '{{.Config.WorkingDir}}')
          echo "Original ENTRYPOINT: $ENTRYPOINT_JSON"
          echo "Original CMD: $CMD_JSON"

          {
            echo "FROM bfe-squashed-base:temp"
            echo "$ENV_VARS"
            echo "WORKDIR ${WORKDIR:-/}"
            if [ "$ENTRYPOINT_JSON" != "null" ] && [ -n "$ENTRYPOINT_JSON" ]; then
              echo "ENTRYPOINT $ENTRYPOINT_JSON"
            fi
            if [ "$CMD_JSON" != "null" ] && [ -n "$CMD_JSON" ]; then
              echo "CMD $CMD_JSON"
            fi
          } > Dockerfile.bfe-squashed

          echo "Generated Dockerfile:" && cat Dockerfile.bfe-squashed
          docker build -f Dockerfile.bfe-squashed -t bfe-squashed-final:temp .

          LAYER_COUNT=$(docker inspect bfe-squashed-final:temp | jq '.[0].RootFS.Layers | length')
          echo "Squashed image has $LAYER_COUNT layer(s)"

          docker rm bfe-squash-temp
          docker rmi bfe-squashed-base:temp || true
          rm -f bfe-squashed.tar Dockerfile.bfe-squashed

          SERVICE_REPO_PATH="${{ env.REPO_PATH }}"
          docker tag bfe-squashed-final:temp ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.buyer_frontend_image}}
          echo "Pushing buyer frontend service to ACR..."
          docker push ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.buyer_frontend_image}}

          echo "‚úÖ Successfully pushed buyer frontend service image (squashed):"
          echo "  - ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.buyer_frontend_image}}"

          docker rmi bfe-squashed-final:temp || true
          docker rmi "$LOADED_IMAGE" || true
        else
          echo "‚ùå buyer_frontend_service_image.tar not found"
          exit 1
        fi

    - name: Cleanup build artifacts (Docker Push Job)
      if: always()
      run: |
        echo "üßπ Cleaning up build artifacts from docker push job..."

        # Clean up any existing Docker artifacts
        echo "Cleaning existing Docker containers and images..."
        docker container prune -f || true
        docker image prune -a -f || true
        docker system prune -f || true
        
        # Clean up workspace from previous runs
        echo "Cleaning workspace from previous runs..."
        sudo rm -rf ${GITHUB_WORKSPACE}/* || true
        sudo rm -rf ${GITHUB_WORKSPACE}/.* 2>/dev/null || true
        
        # Clean up dist directories from previous builds
        echo "Cleaning up distribution directories..."
        sudo rm -rf ./dist/ || true
        sudo rm -rf ../dist/ || true

  generate-sboms:
    needs: docker-push-to-acr
    runs-on: self-hosted
    if: ${{ github.event.inputs.push_to_acr == 'true' && github.event.inputs.generate_sboms == 'true' }}
    
    steps:
    - name: Checkout Repository for SBOM
      uses: actions/checkout@v4
      with:
        repository: ispirt/ad-selection-api.bidding-and-auction-servers
        ref: ${{ github.event.inputs.build_ref }}
        fetch-depth: 0
        
    - name: Install Syft
      run: |
        echo "üì¶ Installing Syft..."
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin
        syft version
        
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
        password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}
        
    - name: Generate SBOMs
      run: |
        BUILD_FLAVOR_INPUT="${{ github.event.inputs.build_flavor }}"
        if [ "$BUILD_FLAVOR_INPUT" = "non_prod" ]; then
          BUILD_FLAVOR="nonprod"
        else
          BUILD_FLAVOR="$BUILD_FLAVOR_INPUT"
        fi
        RELEASE_VERSION="${{ github.event.inputs.release_tag }}"
        SERVICE_REPO_PATH="${{ env.REPO_PATH }}"
        SERVICES="${{ github.event.inputs.services }}"
        
        echo "üîç Generating SBOMs..."
        
        # Generate SBOM for Bidding Service if included
        if echo "$SERVICES" | grep -q "bidding_service"; then
          BIDDING_IMAGE="${{ env.REGISTRY }}/${SERVICE_REPO_PATH}/bidding-service:${BUILD_FLAVOR}-${RELEASE_VERSION}"
          echo "Generating SBOM for Bidding Service: $BIDDING_IMAGE"
          syft $BIDDING_IMAGE -o spdx-json=bidding-service-${BUILD_FLAVOR}-sbom.spdx.json
        fi
        
        # Generate SBOM for Buyer Frontend Service if included
        if echo "$SERVICES" | grep -q "buyer_frontend_service"; then
          BUYER_FRONTEND_IMAGE="${{ env.REGISTRY }}/${SERVICE_REPO_PATH}/buyer-frontend-service:${BUILD_FLAVOR}-${RELEASE_VERSION}"
          echo "Generating SBOM for Buyer Frontend Service: $BUYER_FRONTEND_IMAGE"
          syft $BUYER_FRONTEND_IMAGE -o spdx-json=buyer-frontend-service-${BUILD_FLAVOR}-sbom.spdx.json
        fi
        
        # Generate SBOM for repository
        echo "Generating SBOM for repository"
        syft dir:. -o spdx-json=ba-repo-sbom.spdx.json
        
        echo "‚úÖ SBOMs generated successfully"
        ls -lh *-sbom.spdx.json
        
    - name: Upload SBOM Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: sbom-files-${{ github.event.inputs.build_flavor }}-${{ github.event.inputs.release_tag }}
        path: |
          *-sbom.spdx.json
        retention-days: 90
        
    - name: Cleanup SBOM Job
      if: always()
      run: |
        echo "üßπ Cleaning up SBOM generation artifacts..."
        rm -f *-sbom.spdx.json || true
        docker logout ${{ env.REGISTRY }} || true
        echo "‚úÖ SBOM job cleanup completed"

