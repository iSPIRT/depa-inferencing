name: Release build for Key-Value Service

on:
  workflow_dispatch:
    inputs:
      build_flavor:
        description: 'Build flavor'
        required: true
        default: 'nonprod'
        type: choice
        options:
        - nonprod
        - prod
      services:
        description: 'Services to build (comma-separated)'
        required: true
        default: 'key_value_service'
        type: string
      run_tests:
        description: 'Run tests'
        required: true
        default: false
        type: boolean
      run_precommit_checks:
        description: 'Run precommit checks'
        required: true
        default: false
        type: boolean
      release_tag:
        description: 'Release version for Docker images (e.g., 1.0.0.0)'
        required: true
        default: '1.2.0.0'
        type: string
      push_to_acr:
        description: 'Push images to Azure Container Registry'
        required: true
        default: true
        type: boolean

env:
  BUILD_TYPE: Release
  REGISTRY: ${{ vars.REGISTRY }}
  REPO_PATH: ${{ vars.REPO_PATH }}
  
jobs:
  build:
    runs-on: self-hosted
    timeout-minutes: 1440 # 24 hours
    steps:
    - name: Display Manual Trigger Parameters
      run: |
        echo "ðŸš€ Manual Build Triggered on Self-Hosted Runner"
        echo "Build Flavor: ${{ github.event.inputs.build_flavor }}"
        echo "Services: ${{ github.event.inputs.services }}"
        echo "Run tests?: ${{ github.event.inputs.run_tests }}"
        echo "Run precommit checks?: ${{ github.event.inputs.run_precommit_checks }}"
        echo "Release Version: ${{ github.event.inputs.release_tag }}"
        echo "Push to ACR: ${{ github.event.inputs.push_to_acr }}"

    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        repository: ispirt/protected-auction-key-value-service
        ref: main
        fetch-depth: 0
        
    - name: Setup Build Environment
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake git

    - name: Setup Dependencies  
      run: |
        # Remove any conflicting Docker packages
        sudo apt-get remove -y docker docker-engine docker.io containerd runc || true
        sudo apt-get autoremove -y
        
        # Install build dependencies
        sudo apt-get install -y \
          apt-transport-https \
          ca-certificates \
          curl \
          gnupg \
          lsb-release \
          libssl-dev \
          libcurl4-openssl-dev \
          libprotobuf-dev \
          protobuf-compiler \
          pkg-config

    - name: Install Docker
      run: |
        # Free up memory first
        sudo apt-get clean
        sudo apt-get autoclean
        sudo rm -rf /var/lib/apt/lists/*
        
        # Download and run Docker installation script
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        
        # Clean up installation script
        rm get-docker.sh
        
        # Add user to docker group
        sudo usermod -aG docker $USER        
        
        # Verify installation
        docker --version

    - name: Setup Docker
      run: |
        sudo systemctl start docker
        sudo systemctl enable docker
        sudo usermod -aG docker $USER

    - name: Make Build Script Executable
      run: |
        chmod +x ./production/packaging/build_and_test_all_in_docker
        
    - name: Parse Service Paths
      id: parse_services
      run: |
        # Convert comma-separated services to --service-path arguments
        services="${{ github.event.inputs.services }}"
        service_args=""
        IFS=',' read -ra SERVICE_ARRAY <<< "$services"
        for service in "${SERVICE_ARRAY[@]}"; do
          service_args="$service_args --service-path ${service// /}"
        done
        echo "service_args=$service_args" >> $GITHUB_OUTPUT
        echo "Parsed service arguments: $service_args"
        
    - name: Run Custom Build Command
      run: |
        TEST_FLAG=""
        PRECOMMIT_FLAG="--no-precommit"

        if [ "${{ github.event.inputs.run_tests }}" = "true" ]; then
          TEST_FLAG="--with-tests"
        fi

        if [ "${{ github.event.inputs.run_precommit_checks }}" = "true" ]; then
          PRECOMMIT_FLAG=""
        fi
        
        ./production/packaging/build_and_test_all_in_docker \
        --instance azure_microsoft \
        --platform azure_microsoft \
        --mode ${{ github.event.inputs.build_flavor }} \
          $TEST_FLAG \
          $PRECOMMIT_FLAG
          
    - name: List Generated Tar Files
      run: |
        echo "Contents of dist/azure directory:"
        ls -la dist/azure/ || echo "dist/azure directory not found"
        find dist/azure/ -name "*.tar" -type f | head -10

    - name: Cleanup build artifacts (Build Job)
      if: always()  
      run: |
        echo "ðŸ§¹ Cleaning up build artifacts from build job..."
        
        # Clean up Docker artifacts
        echo "Cleaning Docker containers and images..."
        docker container prune -f || true
        docker image prune -f || true
        
        # Clean up temporary files and caches
        echo "Cleaning up temporary files..."
        sudo rm -rf /tmp/docker-* || true
        sudo rm -rf /tmp/buildkit-* || true
            
        # Show disk space after cleanup
        echo "ðŸ“Š Disk space after cleanup:"
        df -h
        
        echo "âœ… Build job cleanup completed"

  docker-push-to-acr:
    needs: build
    runs-on: self-hosted
    if: ${{ github.event.inputs.push_to_acr == 'true' }}
    
    steps:
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
        password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}

    - name: Generate Service-Specific Docker Tags
      id: generate_tags
      run: |
        BUILD_FLAVOR="${{ github.event.inputs.build_flavor }}"
        RELEASE_VERSION="${{ github.event.inputs.release_tag }}"

        # Generate service-specific tags
        KV_SERVICE_IMAGE="key-value-service:${BUILD_FLAVOR}-${RELEASE_VERSION}"

        echo "key_value_service_image=$KV_SERVICE_IMAGE" >> $GITHUB_OUTPUT

        echo "âœ… Service-specific Docker tags generated:"
        echo "Key Value Service image: $KV_SERVICE_IMAGE"

    - name: Load and Push Key Value Service Image
      if: contains(github.event.inputs.services, 'key_value_service')
      run: |
        # Load the key value service image from tar file
        if [ -f "./dist/key_value_service_image.tar" ]; then
          echo "Loading key_value_service_image.tar..."
          LOAD_OUTPUT=$(docker load -i ./dist/key_value_service_image.tar)

          # Get the loaded image name
          LOADED_IMAGE=$(echo "$LOAD_OUTPUT" | grep "Loaded image:" | sed 's/Loaded image: //')
          echo "Loaded image: $LOADED_IMAGE"
          
          # ============================================
          # SQUASH IMAGE TO SINGLE LAYER (for CCE policy compatibility)
          # ============================================
          echo "ðŸ”§ Squashing image layers for CCE policy compatibility..."
          
          # step 1: create container from loaded image
          docker create --name kv-squash-temp $LOADED_IMAGE
          
          # step 2: export container filesystem (flattens to single layer)
          docker export kv-squash-temp -o kv-squashed.tar
          
          # step 3: import as new image (single layer, no metadata)
          SQUASHED_BASE=$(docker import kv-squashed.tar kv-squashed-base:temp)
          echo "Created squashed base image: $SQUASHED_BASE"
          
          # step 4: extract original image metadata
          ENTRYPOINT_JSON=$(docker inspect $LOADED_IMAGE --format '{{json .Config.Entrypoint}}')
          ENV_VARS=$(docker inspect $LOADED_IMAGE --format '{{range .Config.Env}}ENV {{.}}{{"\n"}}{{end}}')
          WORKDIR=$(docker inspect $LOADED_IMAGE --format '{{.Config.WorkingDir}}')
          
          echo "Original ENTRYPOINT: $ENTRYPOINT_JSON"
          echo "Original ENV vars: $ENV_VARS"
          
          # step 5: create Dockerfile to restore metadata
          cat > Dockerfile.squashed << DOCKERFILE_EOF
          FROM kv-squashed-base:temp
          $ENV_VARS
          WORKDIR ${WORKDIR:-/}
          ENTRYPOINT $ENTRYPOINT_JSON
          DOCKERFILE_EOF
          
          echo "Generated Dockerfile.squashed:"
          cat Dockerfile.squashed
          
          # step 6: build final squashed image with metadata
          docker build -f Dockerfile.squashed -t kv-squashed-final:temp .
          
          # step 7: verify single layer
          LAYER_COUNT=$(docker inspect kv-squashed-final:temp | jq '.[0].RootFS.Layers | length')
          echo "âœ… Squashed image has $LAYER_COUNT layer(s)"
          
          # Cleanup temp artifacts
          docker rm kv-squash-temp
          docker rmi kv-squashed-base:temp || true
          rm -f kv-squashed.tar Dockerfile.squashed
          
          # Use squashed image for tagging
          FINAL_IMAGE="kv-squashed-final:temp"
          # ============================================
          
          # Tag the image with service-specific naming following Azure best practices
          SERVICE_REPO_PATH="${{ env.REPO_PATH }}"

          # Service-specific tag: key-value-service:non-prod:1.0.0.0
          docker tag $FINAL_IMAGE ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.key_value_service_image}}
            
          # Push all tags to Azure Container Registry
          echo "Pushing key value service to ACR with service-specific tags..."
          docker push ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.key_value_service_image }}
          echo "âœ… Successfully pushed key value service image with tags:"
          echo "  - ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.key_value_service_image }}"
          
          # Cleanup final temp image
          docker rmi $FINAL_IMAGE || true
          docker rmi $LOADED_IMAGE || true
        else
          echo "âŒ key_value_service_image.tar not found"
          exit 1
        fi

    - name: Cleanup build artifacts (Docker Push Job)
      if: always()
      run: |
        echo "ðŸ§¹ Cleaning up build artifacts from docker push job..."
        docker container prune -f || true
        docker image prune -f || true
        sudo chown -R $(whoami):$(whoami) ${GITHUB_WORKSPACE} || true
        echo "âœ… Docker push job cleanup completed"
