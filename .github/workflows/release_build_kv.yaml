name: Release build for Key-Value Service

permissions:
  contents: read

on:
  workflow_dispatch:
    inputs:
      build_ref:
        description: 'Branch or tag to build from'
        required: true
        default: 'main'
        type: string
      build_flavor:
        description: 'Build flavor'
        required: true
        default: 'nonprod'
        type: choice
        options:
        - nonprod
        - prod
      run_tests:
        description: 'Run tests'
        required: true
        default: false
        type: boolean
      run_precommit_checks:
        description: 'Run precommit checks'
        required: true
        default: false
        type: boolean
      release_tag:
        description: 'Release version for Docker images (e.g., 1.0.0.0)'
        required: true
        default: '1.2.0.4'
        type: string
      push_to_acr:
        description: 'Push images to Azure Container Registry'
        required: true
        default: true
        type: boolean
      generate_sboms:
        description: 'Generate SBOMs (requires push to ACR)'
        required: true
        default: false
        type: boolean

env:
  BUILD_TYPE: Release
  REGISTRY: ${{ vars.REGISTRY }}
  REPO_PATH: ${{ vars.REPO_PATH }}
  
jobs:
  build:
    runs-on: self-hosted
    timeout-minutes: 1440 # 24 hours
    steps:
    - name: Display Manual Trigger Parameters
      run: |
        echo "üöÄ Manual Build Triggered on Self-Hosted Runner"
        echo "Build Ref: ${{ github.event.inputs.build_ref }}"
        echo "Build Flavor: ${{ github.event.inputs.build_flavor }}"
        echo "Run tests?: ${{ github.event.inputs.run_tests }}"
        echo "Run precommit checks?: ${{ github.event.inputs.run_precommit_checks }}"
        echo "Release Version: ${{ github.event.inputs.release_tag }}"
        echo "Push to ACR: ${{ github.event.inputs.push_to_acr }}"
        echo "Generate SBOMs: ${{ github.event.inputs.generate_sboms }}"

    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        repository: ispirt/protected-auction-key-value-service
        ref: ${{ github.event.inputs.build_ref }}
        fetch-depth: 0
        
    - name: Setup Build Environment
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake git

    - name: Setup Dependencies  
      run: |
        # Remove any conflicting Docker packages
        sudo apt-get remove -y docker docker-engine docker.io containerd runc || true
        sudo apt-get autoremove -y
        
        # Install build dependencies
        sudo apt-get install -y \
          apt-transport-https \
          ca-certificates \
          curl \
          gnupg \
          lsb-release \
          libssl-dev \
          libcurl4-openssl-dev \
          libprotobuf-dev \
          protobuf-compiler \
          pkg-config

    - name: Install Docker
      run: |
        # Free up memory first
        sudo apt-get clean
        sudo apt-get autoclean
        sudo rm -rf /var/lib/apt/lists/*
        
        # Download and run Docker installation script
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        
        # Clean up installation script
        rm get-docker.sh
        
        # Add user to docker group
        sudo usermod -aG docker $USER        
        
        # Verify installation
        docker --version

    - name: Setup Docker
      run: |
        sudo systemctl start docker
        sudo systemctl enable docker
        sudo usermod -aG docker $USER

    - name: Make Build Script Executable
      run: |
        chmod +x ./production/packaging/build_and_test_all_in_docker
        
    - name: Run Custom Build Command
      run: |
        TEST_FLAG=""
        PRECOMMIT_FLAG="--no-precommit"

        if [ "${{ github.event.inputs.run_tests }}" = "true" ]; then
          TEST_FLAG="--with-tests"
        fi

        if [ "${{ github.event.inputs.run_precommit_checks }}" = "true" ]; then
          PRECOMMIT_FLAG=""
        fi
        
        ./production/packaging/build_and_test_all_in_docker \
        --instance azure_microsoft \
        --platform azure_microsoft \
        --mode ${{ github.event.inputs.build_flavor }} \
          $TEST_FLAG \
          $PRECOMMIT_FLAG
          
    - name: List Generated Tar Files
      run: |
        echo "Contents of dist/azure directory:"
        ls -la dist/azure/ || echo "dist/azure directory not found"
        find dist/azure/ -name "*.tar" -type f | head -10

    - name: Cleanup build artifacts (Build Job)
      if: always()  
      run: |
        echo "üßπ Cleaning up build artifacts from build job..."
        
        # Clean up Docker artifacts
        echo "Cleaning Docker containers and images..."
        docker container prune -f || true
        docker image prune -f || true
        
        # Clean up temporary files and caches
        echo "Cleaning up temporary files..."
        sudo rm -rf /tmp/docker-* || true
        sudo rm -rf /tmp/buildkit-* || true
            
        # Show disk space after cleanup
        echo "üìä Disk space after cleanup:"
        df -h
        
        echo "‚úÖ Build job cleanup completed"

  docker-push-to-acr:
    needs: build
    runs-on: self-hosted
    if: ${{ github.event.inputs.push_to_acr == 'true' }}
    
    steps:
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
        password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}

    - name: Generate Service-Specific Docker Tags
      id: generate_tags
      run: |
        BUILD_FLAVOR="${{ github.event.inputs.build_flavor }}"
        RELEASE_VERSION="${{ github.event.inputs.release_tag }}"

        # Generate service-specific tags
        KV_SERVICE_IMAGE="key-value-service:${BUILD_FLAVOR}-${RELEASE_VERSION}"

        echo "key_value_service_image=$KV_SERVICE_IMAGE" >> $GITHUB_OUTPUT

        echo "‚úÖ Service-specific Docker tags generated:"
        echo "Key Value Service image: $KV_SERVICE_IMAGE"

    - name: Load and Push Key Value Service Image
      run: |
        # Load the key value service image from tar file
        if [ -f "./dist/key_value_service_image.tar" ]; then
          echo "Loading key_value_service_image.tar..."
          LOAD_OUTPUT=$(docker load -i ./dist/key_value_service_image.tar)

          # Get the loaded image name
          LOADED_IMAGE=$(echo "$LOAD_OUTPUT" | grep "Loaded image:" | sed 's/Loaded image: //')
          echo "Loaded image: $LOADED_IMAGE"
          
          # ============================================
          # SQUASH IMAGE TO SINGLE LAYER (for CCE policy compatibility)
          # ============================================
          echo "üîß Squashing image layers for CCE policy compatibility..."
          
          # step 1: create container from loaded image
          docker create --name kv-squash-temp $LOADED_IMAGE
          
          # step 2: export container filesystem (flattens to single layer)
          docker export kv-squash-temp -o kv-squashed.tar
          
          # step 3: import as new image (single layer, no metadata)
          SQUASHED_BASE=$(docker import kv-squashed.tar kv-squashed-base:temp)
          echo "Created squashed base image: $SQUASHED_BASE"
          
          # step 4: extract original image metadata
          ENTRYPOINT_JSON=$(docker inspect $LOADED_IMAGE --format '{{json .Config.Entrypoint}}')
          ENV_VARS=$(docker inspect $LOADED_IMAGE --format '{{range .Config.Env}}ENV {{.}}{{"\n"}}{{end}}')
          WORKDIR=$(docker inspect $LOADED_IMAGE --format '{{.Config.WorkingDir}}')
          
          echo "Original ENTRYPOINT: $ENTRYPOINT_JSON"
          echo "Original ENV vars: $ENV_VARS"
          
          # step 5: create Dockerfile to restore metadata
          echo "FROM kv-squashed-base:temp" > Dockerfile.squashed
          echo "$ENV_VARS" >> Dockerfile.squashed
          echo "WORKDIR ${WORKDIR:-/}" >> Dockerfile.squashed
          echo "ENTRYPOINT $ENTRYPOINT_JSON" >> Dockerfile.squashed
          
          echo "Generated Dockerfile.squashed:"
          cat Dockerfile.squashed
          
          # step 6: build final squashed image with metadata
          docker build -f Dockerfile.squashed -t kv-squashed-final:temp .
          
          # step 7: verify single layer
          LAYER_COUNT=$(docker inspect kv-squashed-final:temp | jq '.[0].RootFS.Layers | length')
          echo "Squashed image has $LAYER_COUNT layers"
          
          # cleanup temp artifacts
          docker rm kv-squash-temp
          docker rmi kv-squashed-base:temp || true
          rm -f kv-squashed.tar Dockerfile.squashed
          
          # use squashed image for tagging
          FINAL_IMAGE="kv-squashed-final:temp"
          # ============================================
          
          # Tag the image with service-specific naming following Azure best practices
          SERVICE_REPO_PATH="${{ env.REPO_PATH }}"

          # Service-specific tag: key-value-service:non-prod:1.0.0.0
          docker tag $FINAL_IMAGE ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.key_value_service_image}}
            
          # Push all tags to Azure Container Registry
          echo "Pushing key value service to ACR with service-specific tags..."
          docker push ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.key_value_service_image }}
          echo "‚úÖ Successfully pushed key value service image with tags:"
          echo "  - ${{ env.REGISTRY }}/$SERVICE_REPO_PATH/${{ steps.generate_tags.outputs.key_value_service_image }}"
          
          # Cleanup final temp image
          docker rmi $FINAL_IMAGE || true
          docker rmi $LOADED_IMAGE || true
        else
          echo "‚ùå key_value_service_image.tar not found"
          exit 1
        fi

    - name: Cleanup build artifacts (Docker Push Job)
      if: always()
      run: |
        echo "üßπ Cleaning up build artifacts from docker push job..."
        docker container prune -f || true
        docker image prune -f || true
        sudo chown -R $(whoami):$(whoami) ${GITHUB_WORKSPACE} || true
        echo "‚úÖ Docker push job cleanup completed"

  generate-sboms:
    needs: docker-push-to-acr
    runs-on: self-hosted
    if: ${{ github.event.inputs.push_to_acr == 'true' && github.event.inputs.generate_sboms == 'true' }}
    
    steps:
    - name: Checkout Repository for SBOM
      uses: actions/checkout@v4
      with:
        repository: ispirt/protected-auction-key-value-service
        ref: ${{ github.event.inputs.build_ref }}
        fetch-depth: 0
        
    - name: Install Syft
      run: |
        echo "üì¶ Installing Syft..."
        curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sudo sh -s -- -b /usr/local/bin
        syft version
        
    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.REGISTRY }}
        username: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
        password: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}
        
    - name: Generate SBOMs
      run: |
        BUILD_FLAVOR="${{ github.event.inputs.build_flavor }}"
        RELEASE_VERSION="${{ github.event.inputs.release_tag }}"
        SERVICE_REPO_PATH="${{ env.REPO_PATH }}"
        
        echo "üîç Generating SBOMs..."
        
        # Generate SBOM for ACR image
        ACR_IMAGE="${{ env.REGISTRY }}/${SERVICE_REPO_PATH}/key-value-service:${BUILD_FLAVOR}-${RELEASE_VERSION}"
        echo "Generating SBOM for ACR image: $ACR_IMAGE"
        syft $ACR_IMAGE -o spdx-json=kv-${BUILD_FLAVOR}-sbom.spdx.json
        
        # Generate SBOM for repository
        echo "Generating SBOM for repository"
        syft dir:. -o spdx-json=kv-repo-sbom.spdx.json
        
        echo "‚úÖ SBOMs generated successfully"
        ls -lh kv-*-sbom.spdx.json
        
    - name: Upload SBOM Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: sbom-files-${{ github.event.inputs.build_flavor }}-${{ github.event.inputs.release_tag }}
        path: |
          kv-*-sbom.spdx.json
          kv-repo-sbom.spdx.json
        retention-days: 90
        
    - name: Cleanup SBOM Job
      if: always()
      run: |
        echo "üßπ Cleaning up SBOM generation artifacts..."
        rm -f kv-*-sbom.spdx.json || true
        docker logout ${{ env.REGISTRY }} || true
        echo "‚úÖ SBOM job cleanup completed"
